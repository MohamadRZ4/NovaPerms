<?php

declare(strict_types=1);

namespace MohamadRZ\NovaPerms;

use MohamadRZ\NovaPerms\configs\ConfigManager;
use MohamadRZ\NovaPerms\context\ContextManager;
use MohamadRZ\NovaPerms\context\ImmutableContextSet;
use MohamadRZ\NovaPerms\context\SimpleContext;
use MohamadRZ\NovaPerms\model\GroupManager;
use MohamadRZ\NovaPerms\model\NodeManager;
use MohamadRZ\NovaPerms\model\UserManager;
use MohamadRZ\NovaPerms\node\Types\DisplayNameNode;
use MohamadRZ\NovaPerms\node\Types\InheritanceNode;
use MohamadRZ\NovaPerms\node\Types\MetaNode;
use MohamadRZ\NovaPerms\node\Types\PermissionNode;
use MohamadRZ\NovaPerms\node\Types\PrefixNode;
use MohamadRZ\NovaPerms\node\Types\SuffixNode;
use MohamadRZ\NovaPerms\node\Types\WeightNode;
use MohamadRZ\NovaPerms\storage\implementations\StorageImplementation;
use MohamadRZ\NovaPerms\storage\Storage;
use MohamadRZ\NovaPerms\storage\StorageFactory;
use MohamadRZ\NovaPerms\timings\Timings;
use MohamadRZ\NovaPerms\utils\Duration;
use MohamadRZ\NovaPerms\utils\ExecuteTimer;
use pocketmine\player\Player;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\SingletonTrait;

class NovaPermsPlugin extends PluginBase {
    use SingletonTrait;

    private static string $datePath;
    private static ConfigManager $configManager;
    private static Timings $timings;
    private static NodeManager $permissionManager;
    private static UserManager $userManager;
    private static Storage $storage;
    private static GroupManager $groupManager;
    private static ContextManager $contextManager;

    protected function onLoad(): void
    {
        self::setInstance($this);
        parent::onLoad(); // TODO: Change the autogenerated stub
    }

    protected function onEnable(): void
    {
        $version = $this->getDescription()->getVersion();
        $softWareName = $this->getServer()->getName();
        $softVersion = $this->getServer()->getVersion();

        $logo = "
        
                §l§eNovaPerms §7| §bPermission System §8• §7v§a$version §r
                  §7running on §b$softWareName §8/ §7$softVersion
";

        $this->getServer()->getLogger()->info($logo);

        $timer = new ExecuteTimer();

        self::$datePath = $this->getDataFolder();
        self::$configManager = new ConfigManager(self::$datePath);
        self::$timings = new Timings(self::$datePath . "/timings/", self::$configManager);
        self::$storage = new Storage($this);

        self::$contextManager = new ContextManager(self::$datePath);
        self::$permissionManager = new NodeManager();
        self::$groupManager = new GroupManager();
        self::$userManager = new UserManager();

        $time = $timer->end();
        $this->getLogger()->info("§aSuccessfully enabled! §7(Took §b" . $time . "ms§7)");
        parent::onEnable();
    }


    public static function getInstance(): NovaPermsPlugin
    {
        return self::$instance;
    }

    public static function getDatePath(): string
    {
        return self::$datePath;
    }

    /**
     * @return ConfigManager
     */
    public static function getConfigManager(): ConfigManager
    {
        return self::$configManager;
    }

    /**
     * @return Timings
     */
    public static function getTimings(): Timings
    {
        return self::$timings;
    }

    /**
     * @return NodeManager
     */
    public static function getPermissionManager(): NodeManager
    {
        return self::$permissionManager;
    }

    /**
     * @return UserManager
     */
    public static function getUserManager(): UserManager
    {
        return self::$userManager;
    }

    /**
     * @return Storage
     */
    public static function getStorage(): Storage
    {
        return self::$storage;
    }

    /**
     * @return GroupManager
     */
    public static function getGroupManager(): GroupManager
    {
        return self::$groupManager;
    }

    /**
     * @return ContextManager
     */
    public static function getContextManager(): ContextManager
    {
        return self::$contextManager;
    }

/*    public function getPlayerGroups(Player $player, array $allgroups): array
    {
        $playerGroups = [];
        foreach ($allgroups as $group) {
            if ($player->hasPermission("group." . $group->getName())) {
                $playerGroups[] = $group;
            }
        }
        return $playerGroups;
    }

    public function isPlayerInGroup(Player $player, string $groupName): bool {
        return $player->hasPermission("group.".$groupName);
    }

 Context System API Documentation
A flexible context management system for tracking player states and permissions in PocketMine-MP plugins.

Overview
The Context System provides a way to track and manage contextual information about players (like world, gamemode, dimension) for use in permission systems and other conditional logic.

Core Components
Context Interface
Represents a single context with key-value pair.


content_copy
php
interface Context {
    public function getKey(): string;
    public function getValue(): string;
    public function __toString(): string;
}
Usage:


content_copy
php
$context = new SimpleContext('world', 'survival');
echo $context->getKey();     // 'world'
echo $context->getValue();   // 'survival'
echo $context->__toString(); // 'world=survival'
ContextSet Interface
Collection of contexts with useful methods.


content_copy
php
interface ContextSet extends \Countable {
    public function isEmpty(): bool;
    public function size(): int;
    public function getContexts(): array;
    public function containsKey(string $key): bool;
    public function getValues(string $key): array;
    public function contains(Context $context): bool;
    public function toMap(): array;
    public function immutableCopy(): ImmutableContextSet;
    public function mutableCopy(): MutableContextSet;
}
Usage:


content_copy
php
// Check if context set is empty
if ($contextSet->isEmpty()) {
    // Handle empty context
}

// Get total number of contexts
$count = $contextSet->size();

// Check if specific key exists
if ($contextSet->containsKey('world')) {
    $worldValues = $contextSet->getValues('world');
}

// Check if specific context exists
$context = new SimpleContext('gamemode', 'creative');
if ($contextSet->contains($context)) {
    // Context found
}
ImmutableContextSet
Read-only context collection that cannot be modified after creation.

Creation Methods:


content_copy
php
// Create empty context set
$emptySet = ImmutableContextSet::empty();

// Create with single context
$contextSet = ImmutableContextSet::of('world', 'survival');

// Create from array of contexts
$contexts = [new SimpleContext('world', 'survival')];
$contextSet = ImmutableContextSet::fromContexts($contexts);

// Build complex context set
$builder = ImmutableContextSet::builder();
$contextSet = $builder
    ->put('world', 'survival')
    ->put('gamemode', 'creative')
    ->build();
Manipulation Methods:


content_copy
php
// Add new context (returns new instance)
$newSet = $contextSet->with('dimension', 'overworld');

// Remove context (returns new instance)
$newSet = $contextSet->without('gamemode');
$newSet = $contextSet->without('world', 'survival'); // Remove specific value

// Convert to mutable
$mutableSet = $contextSet->mutableCopy();
MutableContextSet
Context collection that can be modified after creation.

Usage:


content_copy
php
// Create empty mutable set
$mutableSet = MutableContextSet::create();

// Add single context
$mutableSet->add('world', 'survival');

// Add multiple values for same key
$mutableSet->add('permission', 'read');
$mutableSet->add('permission', 'write');

// Add all contexts from another set
$mutableSet->addAll($otherContextSet);

// Remove context
$mutableSet->remove('world', 'survival');

// Clear all contexts with specific key
$mutableSet->removeAll('permission');

// Clear everything
$mutableSet->clear();

// Convert to immutable
$immutableSet = $mutableSet->immutableCopy();
ContextManager
Main manager for calculating and handling contexts.

Initialization:


content_copy
php
$manager = new ContextManager('/path/to/config');
Core Methods:


content_copy
php
// Calculate contexts for a player
$player = $event->getPlayer();
$contextSet = $manager->calculateContexts($player);

// Register custom calculator
$customCalculator = new MyCustomCalculator();
$manager->registerCalculator($customCalculator);

// Remove calculator
$manager->unregisterCalculator('my_custom_key');

// Get providers
$staticProvider = $manager->getStaticProvider();
$defaultProvider = $manager->getDefaultProvider();

// Reload configuration
$manager->reload();
Context Calculators
Calculate contexts based on player state.

Built-in Calculators:


content_copy
php
// World Context Calculator
$worldCalc = new WorldContextCalculator();
$contexts = $worldCalc->calculate($player);
// Returns contexts like: world=survival_world

// Gamemode Context Calculator
$gamemodeCalc = new GamemodeContextCalculator();
$contexts = $gamemodeCalc->calculate($player);
// Returns contexts like: gamemode=creative
Custom Calculator:


content_copy
php
class MyCalculator extends ContextCalculator {
    public function getContextKey(): string {
        return 'my_context';
    }

    public function calculate(Player $player): ContextSet {
        $contextSet = MutableContextSet::create();

        // Your calculation logic
        if ($player->hasPermission('special.permission')) {
            $contextSet->add('special', 'true');
        }

        return $contextSet->immutableCopy();
    }
}
Context Providers
StaticContextProvider
Provides fixed contexts from configuration.


content_copy
php
$staticProvider = new StaticContextProvider('/path/to/config');

// Get all static contexts
$contexts = $staticProvider->getStaticContexts();

// Reload from config
$staticProvider->reload();
DefaultContextProvider
Provides default contexts when no specific contexts are found.


content_copy
php
$defaultProvider = new DefaultContextProvider('/path/to/config');
$defaultContexts = $defaultProvider->getDefaultContexts();
Complete Usage Example

content_copy
php
// Initialize the context system
$manager = new ContextManager('/path/to/config');

// Register custom calculator
$manager->registerCalculator(new MyCustomCalculator());

// When player joins or context changes
$player = $event->getPlayer();
$contexts = $manager->calculateContexts($player);

// Check player contexts
if ($contexts->containsKey('world')) {
    $worldName = $contexts->getValues('world')[0];
    echo "Player is in world: " . $worldName;
}

if ($contexts->contains(new SimpleContext('gamemode', 'creative'))) {
    echo "Player is in creative mode";
}

// Use contexts for permission checking
$contextMap = $contexts->toMap();
foreach ($contextMap as $key => $values) {
    echo "Context $key: " . implode(', ', $values) . "
";
}

// Create conditional logic based on contexts
if ($contexts->containsKey('world') &&
    in_array('pvp_world', $contexts->getValues('world'))) {
    // Enable PvP features
}

// Modify contexts if needed
$mutableContexts = $contexts->mutableCopy();
$mutableContexts->add('custom', 'value');
$updatedContexts = $mutableContexts->immutableCopy();
Key Features
Immutable by default: Context sets are immutable for thread safety
Flexible: Support for multiple values per context key
Extensible: Easy to add custom context calculators
Configurable: Static and default contexts from configuration files
Efficient: Optimized for frequent context calculations
Type-safe: Strong typing throughout the API*/


}
